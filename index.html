<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Zen Rings: Master</title>
    <!-- VK Bridge -->
    <script src="https://unpkg.com/@vkontakte/vk-bridge/dist/browser.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap');

        :root {
            /* Light Theme */
            --bg-color: #F0F2F5;
            --container-bg: #ffffff;
            --primary-gradient: linear-gradient(135deg, #6C5CE7, #a29bfe);
            --primary-color: #6C5CE7;
            --secondary-color: #00b894;
            --text-color: #2D3436;
            --sub-text-color: #636e72;
            --card-bg: #ffffff;
            --pill-bg: #ffffff;
            --ui-glass: rgba(255, 255, 255, 0.98);
            --shadow-soft: 0 10px 40px rgba(108, 92, 231, 0.15);
            --shadow-btn: 0 8px 20px rgba(108, 92, 231, 0.3);
            --grid-bg: #DFE6E9;
            --tut-bg: #f1f2f6;
            --tut-cell: #dfe6e9;
        }

        /* Dark Theme */
        body[data-theme="dark"] {
            --bg-color: #121212;
            --container-bg: #1E1E1E;
            --text-color: #E0E0E0;
            --sub-text-color: #A0A0A0;
            --card-bg: #2C2C2C;
            --pill-bg: #2C2C2C;
            --ui-glass: rgba(30, 30, 30, 0.98);
            --shadow-soft: 0 10px 40px rgba(0, 0, 0, 0.5);
            --grid-bg: #333333;
            --tut-bg: #2C2C2C;
            --tut-cell: #444444;
            --shadow-btn: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            font-family: 'Nunito', sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex; justify-content: center; align-items: center;
            color: var(--text-color);
            transition: background-color 0.3s ease;
        }

        #game-container {
            position: relative;
            width: 100%; height: 100%;
            max-width: 500px;
            background: var(--container-bg);
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,0.1);
            transition: background-color 0.3s ease;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* --- UI OVERLAYS --- */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--ui-glass);
            backdrop-filter: blur(15px);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 10;
            opacity: 0; 
            visibility: hidden; 
            transition: opacity 0.3s ease, visibility 0s 0.3s;
        }
        .overlay.active { 
            opacity: 1; 
            visibility: visible;
            transition: opacity 0.3s ease, visibility 0s 0s;
        }

        /* Z-Index Layering */
        #menu-screen { z-index: 20; }
        #settings-overlay { z-index: 30; }
        #rules-overlay { z-index: 35; }

        /* MENU */
        #menu-screen { padding: 30px; }

        .settings-btn-area {
            position: absolute; top: 20px; right: 20px; z-index: 25;
        }

        .logo-area {
            margin-bottom: 30px; text-align: center;
            animation: floatLogo 3s ease-in-out infinite;
        }
        @keyframes floatLogo {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }

        h1 { margin: 0; color: var(--primary-color); font-size: 3.8rem; font-weight: 900; line-height: 0.9; }
        .subtitle { font-size: 1rem; color: var(--sub-text-color); font-weight: 700; letter-spacing: 2px; text-transform: uppercase; margin-top: 10px; }

        .mode-select { display: flex; flex-direction: column; gap: 12px; width: 100%; max-width: 320px; }
        
        .mode-card {
            background: var(--card-bg);
            border: 2px solid transparent;
            border-radius: 20px;
            padding: 15px 20px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            transition: all 0.2s ease;
            position: relative; overflow: hidden; text-align: left;
        }
        .mode-card.active-mode { border-color: var(--primary-color); box-shadow: 0 5px 20px rgba(108, 92, 231, 0.2); }
        .mode-card h3 { margin: 0; font-size: 1.2rem; color: var(--text-color); }
        .mode-card p { margin: 4px 0 0; font-size: 0.85rem; color: var(--sub-text-color); }
        .mode-tag {
            position: absolute; top: 15px; right: 15px;
            font-size: 0.75rem; font-weight: 800; color: var(--primary-color);
            background: rgba(108, 92, 231, 0.1); padding: 4px 8px; border-radius: 8px;
        }

        /* MODAL */
        .modal {
            background: var(--card-bg);
            padding: 2rem 1.5rem;
            border-radius: 35px;
            box-shadow: var(--shadow-soft);
            text-align: center;
            width: 90%; max-width: 340px;
            transform: scale(0.95); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 1px solid rgba(255,255,255,0.05);
        }
        .overlay.active .modal { transform: scale(1); }

        .modal-icon {
            width: 80px; height: 80px;
            margin: 0 auto 20px;
            display: flex; justify-content: center; align-items: center;
        }
        .modal-icon svg { width: 100%; height: 100%; }

        /* --- TUTORIAL --- */
        .tutorial-wrapper {
            display: flex; flex-direction: row; gap: 10px; width: 100%; justify-content: center; margin-bottom: 20px;
        }
        .tutorial-item { flex: 1; display: flex; flex-direction: column; align-items: center; }
        .tutorial-scene {
            width: 100%; height: 100px; background: var(--tut-bg); border-radius: 15px;
            position: relative; overflow: hidden; display: flex; justify-content: center; align-items: center;
        }
        .t-caption {
            font-size: 0.75rem; color: var(--sub-text-color); margin-top: 8px; font-weight: 700; line-height: 1.2;
            height: 2.4em; display: flex; align-items: center; justify-content: center;
        }
        .t-grid { display: grid; grid-template-columns: repeat(3, 25px); gap: 4px; }
        .t-cell { width: 25px; height: 25px; border-radius: 50%; background: var(--tut-cell); position: relative; display: flex; justify-content: center; align-items: center; }
        .t-existing-ring { position: absolute; border: 3px solid var(--primary-color); border-radius: 50%; }
        .t-ring-s { width: 10px; height: 10px; }
        .t-ring-m { width: 18px; height: 18px; }
        .t-ring-l { width: 26px; height: 26px; }
        .t-pointer {
            width: 24px; height: 24px; position: absolute; z-index: 10; top: 50%; left: 50%;
            margin-left: -5px; margin-top: -2px; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2)); opacity: 0;
        }
        .t-pointer svg { width: 100%; height: 100%; fill: var(--text-color); }
        .t-ring-move {
            border: 3px solid var(--primary-color); border-radius: 50%; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); opacity: 0; z-index: 5;
        }
        /* Animations */
        #tut1 .t-ring-move { width: 18px; height: 18px; animation: t1_ring 3s infinite ease-in-out; }
        #tut1 .t-pointer { animation: t1_hand 3s infinite ease-in-out; }
        #tut1 .t-cell:nth-child(2) .t-existing-ring, #tut1 .t-cell:nth-child(3) .t-existing-ring { width: 18px; height: 18px; opacity: 0; animation: t1_appear 3s infinite linear; }
        @keyframes t1_hand { 0%, 15% { transform: translate(10px, 30px); opacity: 0; } 20% { transform: translate(10px, 30px); opacity: 1; } 40% { transform: translate(-29px, 0); } 50%, 80% { transform: translate(-29px, 0); opacity: 1; } 90% { transform: translate(-29px, 0); opacity: 0; } }
        @keyframes t1_ring { 0%, 20% { transform: translate(-50%, 30px); opacity: 0; } 25% { transform: translate(-50%, 30px); opacity: 1; } 40% { transform: translate(calc(-50% - 29px), -50%); } 50% { transform: translate(calc(-50% - 29px), -50%); opacity: 1; } 70% { transform: translate(calc(-50% - 29px), -50%) scale(1.4); opacity: 0; } 100% { opacity: 0; } }
        @keyframes t1_appear { 0%, 50% { opacity: 1; transform: scale(1); } 70% { opacity: 0; transform: scale(1.4); } 100% { opacity: 0; } }
        
        #tut2 .t-ring-move { width: 26px; height: 26px; animation: t2_ring 3s infinite ease-in-out; }
        #tut2 .t-pointer { animation: t2_hand 3s infinite ease-in-out; }
        #tut2 .t-cell:nth-child(2) .t-existing-ring.s { width: 10px; height: 10px; animation: t2_pop 3s infinite; }
        #tut2 .t-cell:nth-child(2) .t-existing-ring.m { width: 18px; height: 18px; animation: t2_pop 3s infinite; }
        @keyframes t2_hand { 0%, 15% { transform: translate(10px, 30px); opacity: 0; } 20% { transform: translate(10px, 30px); opacity: 1; } 40% { transform: translate(0, 0); } 50%, 80% { transform: translate(0, 0); opacity: 1; } 90% { transform: translate(0, 0); opacity: 0; } }
        @keyframes t2_ring { 0%, 20% { transform: translate(-50%, 30px); opacity: 0; } 25% { transform: translate(-50%, 30px); opacity: 1; } 40% { transform: translate(-50%, -50%); } 50% { transform: translate(-50%, -50%); opacity: 1; } 70% { transform: translate(-50%, -50%) scale(1.4); opacity: 0; } 100% { opacity: 0; } }
        @keyframes t2_pop { 0%, 50% { opacity: 1; transform: scale(1); } 70% { opacity: 0; transform: scale(1.4); } 100% { opacity: 0; } }

        /* --- SETTINGS --- */
        .settings-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; color: var(--text-color); font-weight: 700; font-size: 1.1rem; }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary-color); }
        input:checked + .slider:before { transform: translateX(22px); }

        /* --- BUTTONS --- */
        .btn { background: var(--primary-gradient); color: white; border: none; padding: 16px 40px; font-size: 1.1rem; border-radius: 50px; cursor: pointer; font-weight: 800; box-shadow: var(--shadow-btn); transition: transform 0.1s; width: 100%; margin-top: 10px; text-transform: uppercase; letter-spacing: 1px; }
        .btn:active { transform: scale(0.96); }
        .btn-secondary { background: transparent; color: var(--sub-text-color); box-shadow: none; border: 2px solid rgba(128,128,128,0.3); font-size: 0.9rem; }
        .btn-green { background: linear-gradient(135deg, #00b894, #55efc4); box-shadow: 0 5px 15px rgba(0, 184, 148, 0.4); }

        .stat-box { background: var(--tut-bg); border-radius: 20px; padding: 15px; margin: 20px 0; width: 100%; }
        .stat-row { display: flex; justify-content: space-between; color: var(--sub-text-color); font-weight: 700; margin: 5px 0; }

        /* --- HUD --- */
        .hud { position: absolute; top: 0; left: 0; width: 100%; height: 120px; padding: 20px 24px; padding-top: max(20px, env(safe-area-inset-top)); display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; z-index: 5; }
        .hud-left, .hud-right { display: flex; gap: 10px; }
        .pill { background: var(--pill-bg); padding: 8px 16px; border-radius: 18px; box-shadow: 0 4px 15px rgba(0,0,0,0.08); display: flex; flex-direction: column; justify-content: center; min-width: 70px; }
        .pill span { font-size: 0.65rem; color: var(--sub-text-color); font-weight: 800; text-transform: uppercase; margin-bottom: 2px; }
        .pill strong { font-size: 1.2rem; color: var(--text-color); font-weight: 900; line-height: 1; }
        .pill.target { border: 2px solid rgba(108, 92, 231, 0.15); }
        .menu-btn-small { width: 48px; height: 48px; border-radius: 16px; background: var(--pill-bg); border: none; box-shadow: 0 4px 15px rgba(0,0,0,0.08); color: var(--text-color); pointer-events: auto; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: transform 0.1s; }
        .menu-btn-small svg { width: 24px; height: 24px; fill: var(--text-color); }
        .menu-btn-small:active { transform: scale(0.9); }

        .progress-bar-container { position: absolute; top: 0; left: 0; width: 100%; height: 6px; background: rgba(0,0,0,0.05); z-index: 4; transition: opacity 0.5s ease; }
        .progress-bar { height: 100%; background: var(--primary-gradient); width: 0%; transition: width 0.5s ease; }

    </style>
</head>
<body>

<div id="game-container">
    <div class="progress-bar-container" id="prog-cont">
        <div class="progress-bar" id="level-progress"></div>
    </div>

    <!-- HUD -->
    <div class="hud">
        <div class="hud-left">
            <div class="pill">
                <span>Счет</span>
                <strong id="score-display">0</strong>
            </div>
            <div class="pill target" id="target-pill">
                <span>Цель</span>
                <strong id="target-display">1000</strong>
            </div>
        </div>
        <div class="hud-right">
            <div class="pill" style="align-items: flex-end; text-align: right;">
                <span id="level-label">Уровень</span>
                <strong id="level-display">1</strong>
            </div>
            <button class="menu-btn-small" id="pause-btn">
                <svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
            </button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- MENU SCREEN -->
    <div id="menu-screen" class="overlay active">
        <div class="settings-btn-area">
            <button class="menu-btn-small" id="open-settings-btn">
                <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.488.488 0 0 0-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 0 0-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
            </button>
        </div>

        <div class="logo-area">
            <h1>Zen<br>Rings</h1>
            <div class="subtitle">Мастер Колец</div>
        </div>
        
        <div class="mode-select">
            <div class="mode-card active-mode" id="mode-campaign">
                <h3>Путешествие</h3>
                <p>Проходите уровни с растущей сложностью.</p>
                <div class="mode-tag">Ур. <span id="menu-level">1</span></div>
            </div>
            
            <div class="mode-card" id="mode-endless">
                <h3>Дзен</h3>
                <p>Бесконечная игра. Расслабьтесь.</p>
                <div class="mode-tag">Рекорд: <span id="menu-highscore">0</span></div>
            </div>
        </div>

        <div style="width: 100%; max-width: 320px; margin-top: 25px;">
            <button class="btn" id="start-btn">ИГРАТЬ</button>
            <button class="btn btn-secondary" id="rules-btn">КАК ИГРАТЬ</button>
        </div>
    </div>

    <!-- RULES MODAL -->
    <div id="rules-overlay" class="overlay">
        <div class="modal">
            <h2>Обучение</h2>
            <div class="tutorial-wrapper">
                <div class="tutorial-item">
                    <div class="tutorial-scene" id="tut1">
                        <div class="t-grid">
                            <div class="t-cell"></div>
                            <div class="t-cell"><div class="t-existing-ring"></div></div>
                            <div class="t-cell"><div class="t-existing-ring"></div></div>
                        </div>
                        <div class="t-ring-move"></div>
                        <div class="t-pointer">
                            <svg viewBox="0 0 24 24"><path d="M9 11.24V7.5C9 6.12 10.12 5 11.5 5S14 6.12 14 7.5v3.74c1.21-.81 2-2.18 2-3.74C16 5.01 13.99 3 11.5 3S7 5.01 7 7.5c0 1.56.79 2.93 2 3.74zm9.84 4.63l-4.54-2.26c-.17-.07-.35-.11-.54-.11H13v-6c0-.83-.67-1.5-1.5-1.5S10 6.67 10 7.5v10.74l-3.43-.72c-.08-.01-.15-.03-.24-.03-.31 0-.59.13-.79.33l-.79.8 4.94 4.94c.27.27.65.44 1.06.44h6.79c.75 0 1.33-.55 1.44-1.28l.75-5.27c.01-.07.02-.14.02-.2 0-.62-.38-1.16-.91-1.38z"/></svg>
                        </div>
                    </div>
                    <div class="t-caption">Линия цвета</div>
                </div>

                <div class="tutorial-item">
                    <div class="tutorial-scene" id="tut2">
                        <div class="t-grid">
                            <div class="t-cell"></div>
                            <div class="t-cell">
                                <div class="t-existing-ring s"></div>
                                <div class="t-existing-ring m"></div>
                            </div>
                            <div class="t-cell"></div>
                        </div>
                        <div class="t-ring-move"></div>
                        <div class="t-pointer">
                            <svg viewBox="0 0 24 24"><path d="M9 11.24V7.5C9 6.12 10.12 5 11.5 5S14 6.12 14 7.5v3.74c1.21-.81 2-2.18 2-3.74C16 5.01 13.99 3 11.5 3S7 5.01 7 7.5c0 1.56.79 2.93 2 3.74zm9.84 4.63l-4.54-2.26c-.17-.07-.35-.11-.54-.11H13v-6c0-.83-.67-1.5-1.5-1.5S10 6.67 10 7.5v10.74l-3.43-.72c-.08-.01-.15-.03-.24-.03-.31 0-.59.13-.79.33l-.79.8 4.94 4.94c.27.27.65.44 1.06.44h6.79c.75 0 1.33-.55 1.44-1.28l.75-5.27c.01-.07.02-.14.02-.2 0-.62-.38-1.16-.91-1.38z"/></svg>
                        </div>
                    </div>
                    <div class="t-caption">3 кольца (точка)</div>
                </div>
            </div>
            
            <button class="btn" id="close-rules-btn">ВСЁ ПОНЯТНО</button>
        </div>
    </div>

    <!-- SETTINGS MODAL -->
    <div id="settings-overlay" class="overlay">
        <div class="modal">
            <h2>Настройки</h2>
            
            <div class="settings-row">
                <span>Звук</span>
                <label class="switch">
                    <input type="checkbox" id="sound-toggle" checked>
                    <span class="slider"></span>
                </label>
            </div>

            <div class="settings-row">
                <span>Вибрация</span>
                <label class="switch">
                    <input type="checkbox" id="vibro-toggle" checked>
                    <span class="slider"></span>
                </label>
            </div>

            <div class="settings-row">
                <span>Темная тема</span>
                <label class="switch">
                    <input type="checkbox" id="theme-toggle">
                    <span class="slider"></span>
                </label>
            </div>

            <button class="btn" id="close-settings-btn">ЗАКРЫТЬ</button>
        </div>
    </div>

    <!-- PAUSE -->
    <div id="pause-overlay" class="overlay">
        <div class="modal">
            <h2>Пауза</h2>
            <button class="btn" id="resume-btn">ПРОДОЛЖИТЬ</button>
            <button class="btn btn-secondary" id="go-menu-btn-pause">В МЕНЮ</button>
        </div>
    </div>

    <!-- LEVEL WIN -->
    <div id="level-win-overlay" class="overlay">
        <div class="modal">
            <div class="modal-icon" style="color: #00b894;">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
            </div>
            <h2 style="color: var(--secondary-color); margin-top: 0;">Победа!</h2>
            <p>Уровень пройден</p>
            <button class="btn btn-green" id="next-level-btn">СЛЕДУЮЩИЙ</button>
        </div>
    </div>

    <!-- GAME OVER -->
    <div id="gameover-overlay" class="overlay">
        <div class="modal">
            <div class="modal-icon" style="color: #ff7675;">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/></svg>
            </div>
            <h2 style="color: #ff7675; margin-top: 0;">Нет ходов</h2>
            <div class="stat-box">
                <div class="stat-row" style="justify-content: center;">
                    <span style="font-size: 1.5rem; color: var(--text-color);" id="final-score">0</span>
                </div>
                <div style="text-align: center; font-size: 0.8rem; color: var(--sub-text-color);">очков</div>
            </div>
            <button class="btn" id="retry-btn">ЗАНОВО</button>
            <button class="btn btn-secondary" id="go-menu-btn-over">В МЕНЮ</button>
        </div>
    </div>
</div>

<script>
// --- VK BRIDGE ---
const VKHandler = {
    initialized: false,
    levelsPassed: 0,
    init: function() {
        if(typeof vkBridge !== 'undefined') {
            vkBridge.send('VKWebAppInit').then(() => {
                this.initialized = true;
                this.showBanner();
            }).catch(console.log);
        }
    },
    showBanner: function() {
        if(this.initialized) vkBridge.send('VKWebAppShowBannerAd', { banner_location: 'bottom' }).catch(console.log);
    },
    showInterstitial: function() {
        if(this.initialized) vkBridge.send('VKWebAppShowNativeAds', { ad_format: 'interstitial' }).catch(console.log);
    },
    saveData: function(key, value) {
        if(this.initialized) vkBridge.send('VKWebAppStorageSet', { key: key, value: String(value) });
        localStorage.setItem(key, value);
    },
    loadData: async function(key, defaultVal) {
        if(this.initialized) {
            try {
                const data = await vkBridge.send('VKWebAppStorageGet', { keys: [key] });
                if(data.keys && data.keys.length > 0) return data.keys[0].value || defaultVal;
            } catch(e) { console.log(e); }
        }
        return localStorage.getItem(key) || defaultVal;
    },
    checkAdTrigger: function(isGameOver = false) {
        if (isGameOver && selectedMode === 'ENDLESS') {
             this.showInterstitial();
        } else if (!isGameOver) {
            this.levelsPassed++;
            if(this.levelsPassed >= 5) {
                this.levelsPassed = 0;
                this.showInterstitial();
            }
        }
    }
};

// --- SETTINGS ---
const Settings = {
    soundEnabled: true,
    vibrationEnabled: true,
    darkMode: false,
    init: async function() {
        const sound = await VKHandler.loadData('zr_sound', 'true');
        this.soundEnabled = (sound === 'true');
        const vibro = await VKHandler.loadData('zr_vibro', 'true');
        this.vibrationEnabled = (vibro === 'true');
        const theme = await VKHandler.loadData('zr_theme', 'false');
        this.darkMode = (theme === 'true');
        this.apply();
        document.getElementById('sound-toggle').checked = this.soundEnabled;
        document.getElementById('vibro-toggle').checked = this.vibrationEnabled;
        document.getElementById('theme-toggle').checked = this.darkMode;
        
        document.getElementById('sound-toggle').addEventListener('change', (e) => {
            this.soundEnabled = e.target.checked;
            VKHandler.saveData('zr_sound', this.soundEnabled);
        });
        document.getElementById('vibro-toggle').addEventListener('change', (e) => {
            this.vibrationEnabled = e.target.checked;
            VKHandler.saveData('zr_vibro', this.vibrationEnabled);
        });
        document.getElementById('theme-toggle').addEventListener('change', (e) => {
            this.darkMode = e.target.checked;
            this.apply();
            VKHandler.saveData('zr_theme', this.darkMode);
        });
    },
    apply: function() {
        if(this.darkMode) document.body.setAttribute('data-theme', 'dark');
        else document.body.removeAttribute('data-theme');
    }
};

// --- GAME LOGIC ---
const CONFIG = {
    ringSizes: { small: 0.14, medium: 0.23, large: 0.32 }, 
    ringThickness: 0.08, 
    colors: ['#FF7675', '#74B9FF', '#55EFC4', '#FFEAA7', '#A29BFE', '#fd79a8'],
    dragOffset: -80,
    baseTarget: 400,
    targetMult: 1.3,
    bgGridColor: '#DFE6E9',
    slotHighlight: 'rgba(108, 92, 231, 0.25)'
};

const AudioSys = {
    ctx: null,
    init: function() {
        if(this.ctx) return;
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    resume: function() {
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },
    vibrate: function(type) {
        if (!Settings.vibrationEnabled) return;
        
        // VK Native Taptics
        if(VKHandler.initialized) {
            let style = 'light';
            if (type === 'medium') style = 'medium';
            if (type === 'heavy') style = 'heavy';
            vkBridge.send('VKWebAppTapticImpactOccurred', { style: style }).catch(()=>{});
        }
        
        // Web Fallback
        if (navigator.vibrate) {
            if (type === 'light') navigator.vibrate(15);
            else if (type === 'medium') navigator.vibrate(40);
            else if (type === 'heavy') navigator.vibrate([30, 50, 30]);
        }
    },
    playTone: function(freq, type, duration, vol = 0.1) {
        if (!Settings.soundEnabled) return;
        if (!this.ctx) this.init();
        if (this.ctx.state === 'suspended') this.ctx.resume();
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playPickup: function() { this.playTone(300, 'sine', 0.1, 0.05); this.vibrate('light'); },
    playDrop: function() { this.playTone(200, 'sine', 0.15, 0.08); this.vibrate('light'); },
    playError: function() { this.playTone(100, 'sawtooth', 0.2, 0.05); this.vibrate('medium'); },
    playWin: function() { 
        this.playTone(400, 'sine', 0.1, 0.1); 
        setTimeout(() => this.playTone(500, 'sine', 0.1, 0.1), 100);
        setTimeout(() => this.playTone(600, 'sine', 0.3, 0.1), 200);
        this.vibrate('heavy');
    },
    playPop: function(combo) {
        const base = 440 + (combo * 50);
        this.playTone(base, 'sine', 0.15, 0.1);
        setTimeout(() => this.playTone(base * 1.5, 'sine', 0.15, 0.05), 50);
        this.vibrate(combo > 2 ? 'medium' : 'light');
    }
};

const lerp = (a, b, t) => a + (b - a) * t;
const dist = (x1, y1, x2, y2) => Math.sqrt((x1-x2)**2 + (y1-y2)**2);

class RingPiece {
    constructor(rings) {
        this.rings = rings;
        this.x = 0; 
        this.y = 0; 
        this.isDragging = false;
        this.scale = 1;
        this.spawnScale = 0;
        this.active = true;
    }
    draw(ctx, cellSize, x, y, scale = 1) {
        if (!this.active) return;
        if (this.rings.large !== null) this.drawRing(ctx, x, y, cellSize * CONFIG.ringSizes.large * scale, CONFIG.colors[this.rings.large], cellSize * scale);
        if (this.rings.medium !== null) this.drawRing(ctx, x, y, cellSize * CONFIG.ringSizes.medium * scale, CONFIG.colors[this.rings.medium], cellSize * scale);
        if (this.rings.small !== null) this.drawRing(ctx, x, y, cellSize * CONFIG.ringSizes.small * scale, CONFIG.colors[this.rings.small], cellSize * scale);
    }
    drawRing(ctx, x, y, radius, color, cellSize) {
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.strokeStyle = color;
        ctx.lineWidth = cellSize * CONFIG.ringThickness;
        ctx.lineCap = 'round';
        ctx.stroke();
        ctx.beginPath(); ctx.arc(x, y, radius, 3.5, 5.0); 
        ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = cellSize * CONFIG.ringThickness * 0.4; ctx.stroke();
    }
}

class GridCell {
    constructor() { this.rings = { small: null, medium: null, large: null }; this.clearing = false; this.scale = 1; }
    canAccept(p) {
        if (p.small !== null && this.rings.small !== null) return false;
        if (p.medium !== null && this.rings.medium !== null) return false;
        if (p.large !== null && this.rings.large !== null) return false;
        return true;
    }
    add(p) {
        if (p.small !== null) this.rings.small = p.small;
        if (p.medium !== null) this.rings.medium = p.medium;
        if (p.large !== null) this.rings.large = p.large;
    }
    isEmpty() { return this.rings.small === null && this.rings.medium === null && this.rings.large === null; }
}

// Global variable to ensure mode selection works across game instances
let selectedMode = 'CAMPAIGN';

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Defaults until async load
        this.savedLevel = 1;
        this.highScore = 0;
        
        // Load data properly
        VKHandler.init();
        Settings.init();
        
        Promise.all([
            VKHandler.loadData('zr_level', '1'),
            VKHandler.loadData('zr_best', '0')
        ]).then(([lvl, best]) => {
            this.savedLevel = parseInt(lvl);
            this.highScore = parseInt(best);
            this.updateMenuStats();
        });
        
        this.resetGrid();
        this.hand = [null, null, null];
        this.draggedPieceIdx = -1;
        this.dragPos = { x: 0, y: 0 };
        this.screenShake = 0;
        this.state = 'MENU'; 

        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.bindEvents();
        
        requestAnimationFrame(() => this.loop());
    }

    updateMenuStats() {
        document.getElementById('menu-level').innerText = this.savedLevel;
        document.getElementById('menu-highscore').innerText = this.highScore;
    }

    resize() {
        this.width = this.canvas.parentElement.clientWidth;
        this.height = this.canvas.parentElement.clientHeight;
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = this.width * dpr;
        this.canvas.height = this.height * dpr;
        this.ctx.scale(dpr, dpr);

        this.padding = 20;
        const hudHeight = 120;
        const availableHeight = this.height - hudHeight - 20;
        this.boardSize = Math.min(this.width - 40, availableHeight * 0.55); 
        this.cellSize = this.boardSize / 3;
        this.boardX = (this.width - this.boardSize) / 2;
        this.boardY = hudHeight + (availableHeight * 0.1); 
        this.handY = this.boardY + this.boardSize + (availableHeight * 0.1);
        const slotWidth = (this.width - 40) / 3;
        this.handSlots = [
            { x: 20 + slotWidth * 0.5, y: this.handY },
            { x: 20 + slotWidth * 1.5, y: this.handY },
            { x: 20 + slotWidth * 2.5, y: this.handY }
        ];
    }

    resetGrid() {
        this.grid = [];
        for(let r=0; r<3; r++) {
            let row = [];
            for(let c=0; c<3; c++) row.push(new GridCell());
            this.grid.push(row);
        }
    }

    initGame() {
        // Init Audio on user gesture
        AudioSys.init();
        AudioSys.resume();
        
        this.mode = selectedMode;
        
        if (this.mode === 'CAMPAIGN') {
            this.currentLevel = this.savedLevel;
            this.startLevel(this.currentLevel);
        } else {
            this.currentLevel = 1;
            this.score = 0;
            this.targetScore = 0;
            this.resetGrid();
            this.hand = [null, null, null];
            this.spawnHand();
            this.state = 'PLAYING';
            this.updateUI();
        }
    }

    startLevel(lvl) {
        this.currentLevel = lvl;
        this.levelScore = 0;
        this.score = 0;
        this.targetScore = Math.floor(CONFIG.baseTarget * Math.pow(CONFIG.targetMult, lvl - 1));
        this.resetGrid();
        this.hand = [null, null, null];
        this.state = 'PLAYING';
        this.spawnHand();
        this.updateUI();
    }

    spawnHand() {
        for(let i=0; i<3; i++) {
            if(this.hand[i] === null) {
                this.hand[i] = this.generatePiece();
                this.hand[i].x = this.handSlots[i].x;
                this.hand[i].y = this.handSlots[i].y + 60;
            }
        }
        if (!this.canMakeMove()) setTimeout(() => this.triggerGameOver(), 600);
    }

    generatePiece() {
        // Updated endless difficulty scaling
        let difficulty;
        if (this.mode === 'CAMPAIGN') {
            difficulty = this.currentLevel;
        } else {
            // Endless: Increase difficulty every 1200 points
            difficulty = 1 + Math.floor(this.score / 1200);
        }
        
        // Cap max difficulty for colors at 6 (max available colors)
        // Difficulty 1-3: 3 colors
        // Difficulty 4-6: 4 colors
        // Difficulty 7-9: 5 colors
        // Difficulty 10+: 6 colors
        const maxColors = Math.min(CONFIG.colors.length, 3 + Math.floor((difficulty - 1) / 3));
        
        // Increase complex piece chance gradually
        // Cap at 60% complex pieces
        const complexChance = Math.min(0.6, 0.1 + (difficulty * 0.05));
        
        let rings = { small: null, medium: null, large: null };
        const getCol = () => Math.floor(Math.random() * maxColors);
        
        if (Math.random() > complexChance) {
            const r = Math.random();
            if(r < 0.33) rings.small = getCol();
            else if(r < 0.66) rings.medium = getCol();
            else rings.large = getCol();
        } else {
            const baseCol = getCol();
            const mixed = Math.random() > 0.8; 
            if (Math.random() > 0.5) rings.small = mixed ? getCol() : baseCol;
            if (Math.random() > 0.5) rings.medium = mixed ? getCol() : baseCol;
            if (Math.random() > 0.5) rings.large = mixed ? getCol() : baseCol;
            if (rings.small === null && rings.medium === null && rings.large === null) rings.large = baseCol;
        }
        return new RingPiece(rings);
    }

    canMakeMove() {
        for(let i=0; i<3; i++) {
            if(this.hand[i] && this.hand[i].active) {
                for(let r=0; r<3; r++) {
                    for(let c=0; c<3; c++) {
                        if(this.grid[r][c].canAccept(this.hand[i].rings)) return true;
                    }
                }
            }
        }
        if(this.hand.every(p => p === null || !p.active)) return true;
        return false;
    }

    update() {
        if(this.state !== 'PLAYING') return;
        this.hand.forEach((p, i) => {
            if(p && p.active) {
                if(!p.isDragging) {
                    p.x = lerp(p.x, this.handSlots[i].x, 0.2);
                    p.y = lerp(p.y, this.handSlots[i].y, 0.2);
                    p.scale = lerp(p.scale, 1, 0.2);
                } else {
                    p.x = lerp(p.x, this.dragPos.x, 0.4);
                    p.y = lerp(p.y, this.dragPos.y + CONFIG.dragOffset, 0.4);
                    p.scale = lerp(p.scale, 1.1, 0.2);
                }
                if(p.spawnScale < 1) p.spawnScale = lerp(p.spawnScale, 1, 0.15);
            }
        });
        if(this.screenShake > 0) { this.screenShake *= 0.9; if(this.screenShake < 0.5) this.screenShake = 0; }
        for(let r=0; r<3; r++) {
            for(let c=0; c<3; c++) {
                if(this.grid[r][c].clearing) {
                    this.grid[r][c].scale -= 0.1;
                    if(this.grid[r][c].scale <= 0) {
                        this.grid[r][c].rings = {small: null, medium: null, large: null};
                        this.grid[r][c].clearing = false;
                        this.grid[r][c].scale = 1;
                    }
                }
            }
        }
    }

    draw() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.ctx.save();
        if(this.screenShake > 0) this.ctx.translate((Math.random()-0.5)*this.screenShake, (Math.random()-0.5)*this.screenShake);

        // Grid Color based on theme
        const gridColor = getComputedStyle(document.body).getPropertyValue('--grid-bg').trim() || CONFIG.bgGridColor;

        // Board
        this.ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--container-bg').trim();
        this.ctx.shadowColor = 'rgba(0,0,0,0.05)';
        this.ctx.shadowBlur = 20;
        this.ctx.roundRect(this.boardX - 10, this.boardY - 10, this.boardSize + 20, this.boardSize + 20, 25);
        this.ctx.fill();
        this.ctx.shadowColor = 'transparent';

        // Cells
        for(let r=0; r<3; r++) {
            for(let c=0; c<3; c++) {
                const cx = this.boardX + c * this.cellSize + this.cellSize/2;
                const cy = this.boardY + r * this.cellSize + this.cellSize/2;
                this.ctx.beginPath();
                this.ctx.arc(cx, cy, this.cellSize*0.4, 0, Math.PI*2);
                this.ctx.fillStyle = gridColor;
                this.ctx.fill();
            }
        }

        if(this.draggedPieceIdx !== -1) {
            const hC = this.getHoveredCell();
            if(hC && this.grid[hC.r][hC.c].canAccept(this.hand[this.draggedPieceIdx].rings)) {
                const cx = this.boardX + hC.c * this.cellSize + this.cellSize/2;
                const cy = this.boardY + hC.r * this.cellSize + this.cellSize/2;
                this.ctx.beginPath();
                this.ctx.arc(cx, cy, this.cellSize*0.42, 0, Math.PI*2);
                this.ctx.fillStyle = CONFIG.slotHighlight;
                this.ctx.fill();
            }
        }

        for(let r=0; r<3; r++) {
            for(let c=0; c<3; c++) {
                const cell = this.grid[r][c];
                if(!cell.isEmpty() || cell.clearing) {
                    const cx = this.boardX + c * this.cellSize + this.cellSize/2;
                    const cy = this.boardY + r * this.cellSize + this.cellSize/2;
                    const t = new RingPiece(cell.rings);
                    t.draw(this.ctx, this.cellSize, cx, cy, cell.scale);
                }
            }
        }

        this.hand.forEach(p => { if(p && p.active) p.draw(this.ctx, this.cellSize, p.x, p.y, p.scale * p.spawnScale); });
        this.ctx.restore();
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }

    bindEvents() {
        const start = (e) => {
            // Audio Context Resume Hack
            AudioSys.resume();
            
            if(this.state !== 'PLAYING') return;
            const pos = this.getPos(e);
            for(let i=0; i<3; i++) {
                if(this.hand[i] && this.hand[i].active) {
                    if(dist(pos.x, pos.y, this.handSlots[i].x, this.handSlots[i].y) < this.cellSize) {
                        this.draggedPieceIdx = i;
                        this.hand[i].isDragging = true;
                        this.dragPos = pos;
                        AudioSys.playPickup();
                        break;
                    }
                }
            }
        };
        const move = (e) => { if(this.draggedPieceIdx !== -1) { e.preventDefault(); this.dragPos = this.getPos(e); } };
        const end = () => {
            if(this.draggedPieceIdx === -1) return;
            const piece = this.hand[this.draggedPieceIdx];
            const hC = this.getHoveredCell(); 
            if(hC && this.grid[hC.r][hC.c].canAccept(piece.rings)) {
                this.placePiece(hC.r, hC.c, piece);
                this.hand[this.draggedPieceIdx] = null;
                AudioSys.playDrop();
                if(this.hand.every(p => p === null)) this.spawnHand();
                else if(!this.canMakeMove()) setTimeout(() => this.triggerGameOver(), 600);
            } else {
                piece.isDragging = false;
                AudioSys.playError();
            }
            this.draggedPieceIdx = -1;
        };
        const c = this.canvas;
        c.addEventListener('mousedown', start);
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', end);
        c.addEventListener('touchstart', start, {passive: false});
        window.addEventListener('touchmove', move, {passive: false});
        window.addEventListener('touchend', end);

        // Buttons
        document.getElementById('start-btn').addEventListener('click', () => { 
            // Explicit resume on click
            AudioSys.resume();
            document.getElementById('menu-screen').classList.remove('active'); 
            this.initGame(); 
        });
        document.getElementById('rules-btn').addEventListener('click', () => { document.getElementById('rules-overlay').classList.add('active'); });
        document.getElementById('close-rules-btn').addEventListener('click', () => { document.getElementById('rules-overlay').classList.remove('active'); });
        document.getElementById('open-settings-btn').addEventListener('click', () => { document.getElementById('settings-overlay').classList.add('active'); });
        document.getElementById('close-settings-btn').addEventListener('click', () => { document.getElementById('settings-overlay').classList.remove('active'); });
        
        // Mode Selection
        document.getElementById('mode-campaign').addEventListener('click', () => {
             selectedMode = 'CAMPAIGN';
             document.getElementById('mode-campaign').classList.add('active-mode');
             document.getElementById('mode-endless').classList.remove('active-mode');
        });
        document.getElementById('mode-endless').addEventListener('click', () => {
             selectedMode = 'ENDLESS';
             document.getElementById('mode-endless').classList.add('active-mode');
             document.getElementById('mode-campaign').classList.remove('active-mode');
        });

        // Pause
        document.getElementById('pause-btn').addEventListener('click', () => { 
            this.state = 'PAUSED'; 
            document.getElementById('pause-overlay').classList.add('active'); 
        });
        document.getElementById('resume-btn').addEventListener('click', () => { 
            this.state = 'PLAYING'; 
            document.getElementById('pause-overlay').classList.remove('active'); 
        });

        // Next Level
        document.getElementById('next-level-btn').addEventListener('click', () => {
            VKHandler.checkAdTrigger(false);
            document.getElementById('level-win-overlay').classList.remove('active');
            this.startLevel(this.currentLevel + 1);
            this.savedLevel = this.currentLevel;
            VKHandler.saveData('zr_level', this.savedLevel);
        });

        // Navigation
        const toMenu = () => {
            document.querySelectorAll('.overlay').forEach(o => o.classList.remove('active'));
            document.getElementById('menu-screen').classList.add('active');
            this.state = 'MENU';
            this.updateMenuStats();
        };
        document.getElementById('go-menu-btn-pause').addEventListener('click', toMenu);
        document.getElementById('go-menu-btn-over').addEventListener('click', toMenu);
        
        document.getElementById('retry-btn').addEventListener('click', () => {
            document.getElementById('gameover-overlay').classList.remove('active');
            if(this.mode === 'CAMPAIGN') this.startLevel(this.currentLevel);
            else this.initGame();
        });
    }

    getPos(e) {
        const r = this.canvas.getBoundingClientRect();
        const tx = e.touches ? e.touches[0].clientX : e.clientX;
        const ty = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: tx - r.left, y: ty - r.top };
    }

    getHoveredCell() {
        if(this.draggedPieceIdx === -1) return null;
        const pieceX = this.dragPos.x;
        const pieceY = this.dragPos.y + CONFIG.dragOffset;
        for(let r=0; r<3; r++) {
            for(let c=0; c<3; c++) {
                const cx = this.boardX + c * this.cellSize + this.cellSize/2;
                const cy = this.boardY + r * this.cellSize + this.cellSize/2;
                if(dist(pieceX, pieceY, cx, cy) < this.cellSize * 0.5) return {r, c};
            }
        }
        return null;
    }

    placePiece(r, c, piece) {
        this.grid[r][c].add(piece.rings);
        this.checkMatches();
    }

    checkMatches() {
        const matches = new Set();
        const check = (cells) => {
            if(cells.some(c => c.isEmpty())) return;
            if(cells.every(c => c.rings.small !== null)) { const col = cells[0].rings.small; if(cells.every(c => c.rings.small === col)) cells.forEach(c => matches.add(c)); }
            if(cells.every(c => c.rings.medium !== null)) { const col = cells[0].rings.medium; if(cells.every(c => c.rings.medium === col)) cells.forEach(c => matches.add(c)); }
            if(cells.every(c => c.rings.large !== null)) { const col = cells[0].rings.large; if(cells.every(c => c.rings.large === col)) cells.forEach(c => matches.add(c)); }
        };
        // Point Match
        for(let r=0; r<3; r++) {
            for(let c=0; c<3; c++) {
                const cell = this.grid[r][c];
                if(cell.rings.small !== null && cell.rings.medium !== null && cell.rings.large !== null) {
                    if(cell.rings.small === cell.rings.medium && cell.rings.medium === cell.rings.large) matches.add(cell);
                }
            }
        }
        for(let r=0; r<3; r++) check([this.grid[r][0], this.grid[r][1], this.grid[r][2]]);
        for(let c=0; c<3; c++) check([this.grid[0][c], this.grid[1][c], this.grid[2][c]]);
        check([this.grid[0][0], this.grid[1][1], this.grid[2][2]]);
        check([this.grid[0][2], this.grid[1][1], this.grid[2][0]]);

        if(matches.size > 0) {
            let combo = 0;
            matches.forEach(cell => { cell.clearing = true; combo++; });
            this.screenShake = 6 + combo;
            AudioSys.playPop(combo);
            this.addScore(combo * 150 * (matches.size > 3 ? 1.5 : 1));
        }
    }

    addScore(points) {
        const p = Math.floor(points);
        this.score += p;
        this.levelScore += p;
        if (this.mode === 'ENDLESS' && this.score > this.highScore) {
            this.highScore = this.score;
            VKHandler.saveData('zr_best', this.highScore);
        }
        this.updateUI();
        if (this.mode === 'CAMPAIGN' && this.levelScore >= this.targetScore) {
            this.state = 'PAUSED';
            AudioSys.playWin();
            // Removed score from Win Modal as requested
            document.getElementById('level-win-overlay').classList.add('active');
        }
    }

    updateUI() {
        if (this.mode === 'CAMPAIGN') {
            document.getElementById('score-display').innerText = this.levelScore;
            document.getElementById('target-display').innerText = this.targetScore;
            document.getElementById('level-display').innerText = this.currentLevel;
            document.getElementById('target-pill').style.display = 'flex';
            document.getElementById('level-label').innerText = "Уровень";
            document.getElementById('prog-cont').style.opacity = '1';
            const pct = Math.min(100, (this.levelScore / this.targetScore) * 100);
            document.getElementById('level-progress').style.width = pct + '%';
        } else {
            document.getElementById('score-display').innerText = this.score;
            document.getElementById('target-pill').style.display = 'none'; 
            document.getElementById('level-display').innerText = this.highScore;
            document.getElementById('level-label').innerText = "Рекорд";
            document.getElementById('prog-cont').style.opacity = '0';
        }
    }
    
    triggerGameOver() {
        this.state = 'GAMEOVER';
        VKHandler.checkAdTrigger(true);
        document.getElementById('final-score').innerText = this.score;
        document.getElementById('gameover-overlay').classList.add('active');
        AudioSys.playError();
    }
}

if(!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2;
        this.beginPath(); this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath(); return this;
    }
}

window.onload = () => new Game();

</script>
</body>
</html>